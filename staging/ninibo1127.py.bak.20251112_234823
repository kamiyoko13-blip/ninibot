# -*- coding: utf-8 -*-
"""ninibo1127

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zxr-BSuHIRDOyN7QioA4lsa5uSHmm0o9
"""

import os

# â‘  ç’°å¢ƒå¤‰æ•°ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã‚€é–¢æ•°
def load_env_from_file(filename):
    with open(filename) as f:
        for line in f:
            if '=' in line:
                key, value = line.strip().split('=', 1)
                os.environ[key] = value

# â‘¡ èª­ã¿è¾¼ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æŒ‡å®š
load_env_from_file("config.env")  # ã¾ãŸã¯ "keys.log"

# â‘¢ èª­ã¿è¾¼ã‚“ã ç’°å¢ƒå¤‰æ•°ã‚’ä½¿ã†
api_key = os.getenv("API_KEY")
secret_key = os.getenv("SECRET_KEY")

import ccxt

# bitbankã®å–å¼•æ‰€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
bitbank = ccxt.bitbank()

try:
    # ãƒ­ãƒ¼ãƒ‰ãƒãƒ¼ã‚±ãƒƒãƒˆæƒ…å ±
    bitbank.load_markets()

    # BTC/JPYãƒšã‚¢ã®æƒ…å ±ã‹ã‚‰æœ€ä½å–å¼•æ•°é‡ã‚’å–å¾—
    # 'limits'->'amount'->'min' ã®ãƒ‘ã‚¹ã§å–å¾—ã§ãã‚‹ã“ã¨ãŒå¤šã„
    # å–å¼•æ‰€ã«ã‚ˆã£ã¦ã¯ã“ã®æ§‹é€ ãŒç•°ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™
    min_amount = bitbank.markets['BTC/JPY']['limits']['amount']['min']

    print(f"bitbank (BTC/JPY) ã®æœ€ä½å–å¼•æ•°é‡ã¯ {min_amount} BTC ã§ã™ã€‚")

except ccxt.base.errors.ExchangeError as e:
    print(f"å–å¼•æ‰€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
except KeyError:
    print("å¿…è¦ãªæƒ…å ± (æœ€ä½å–å¼•æ•°é‡) ãŒå–å¼•æ‰€æƒ…å ±ã«è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
    print("bitbankã®APIãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")
except Exception as e:
    print(f"ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")

from dotenv import load_dotenv
import os

load_dotenv(dotenv_path='config.env')  # â† å¤‰æ›´å¾Œã®ãƒ•ã‚¡ã‚¤ãƒ«åã«åˆã‚ã›ã¦ã‚‹ã‚ˆ

api_key = os.getenv("API_KEY")
secret_key = os.getenv("SECRET_KEY")

print("API_KEY:", api_key)
print("SECRET_KEY:", secret_key)

import ccxt
import pandas as pd
import time
import os
import datetime
import pytz
import math # mathãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’è¿½åŠ 

# æ—¥æœ¬æ¨™æº–æ™‚ (JST) ã®ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
JST = pytz.timezone('Asia/Tokyo')

# === 1. å–å¼•æ‰€ã¸ã®æ¥ç¶š ===
def connect_to_bitbank():
    """bitbankã«æ¥ç¶šã—ã¾ã™"""
    try:
        # ğŸ”‘ dotenvã§èª­ã¿è¾¼ã‚“ã ã‚­ãƒ¼ã‚’ç›´æ¥ä½¿ç”¨
        from dotenv import load_dotenv # é–¢æ•°å†…ã§å†åº¦ã‚¤ãƒ³ãƒãƒ¼ãƒˆ

        # èª­ã¿è¾¼ã¿ã®ãƒ‘ã‚¹ã¯æ—¢ã«å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ã¯ãšã§ã™ãŒã€å¿µã®ãŸã‚
        load_dotenv(dotenv_path='config.env')

        # dotenvã§èª­ã¿è¾¼ã‚“ã å¤‰æ•°å (API_KEY, SECRET_KEY) ã«åˆã‚ã›ã¦ã‚­ãƒ¼ã‚’å–å¾—
        api_key = os.getenv("API_KEY")
        secret_key = os.getenv("SECRET_KEY")

        # ãƒ‡ãƒãƒƒã‚°ç”¨: å–å¾—ã—ãŸã‚­ãƒ¼ã®ä¸€éƒ¨ã‚’è¡¨ç¤º
        print(f"DEBUG: API Key (partial): {api_key[:4]}...{api_key[-4:]}" if api_key else "DEBUG: API Key: None")
        print(f"DEBUG: Secret Key (partial): {secret_key[:4]}...{secret_key[-4:]}" if secret_key else "DEBUG: Secret Key: None")


        if not api_key or not secret_key:
            print("ã‚¨ãƒ©ãƒ¼ï¼šconfig.envã‹ã‚‰APIã‚­ãƒ¼ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚")
            return None

        # ccxtã‚’ä½¿ã£ã¦bitbankã«æ¥ç¶š
        exchange = ccxt.bitbank({
            'apiKey': api_key, # ä¿®æ­£å¾Œã®å¤‰æ•°åã‚’ä½¿ç”¨
            'secret': secret_key, # ä¿®æ­£å¾Œã®å¤‰æ•°åã‚’ä½¿ç”¨
        })
        print("bitbankã«ccxtã§æ¥ç¶šã—ã¾ã—ãŸã€‚")
        return exchange

    except Exception as e:
        print(f"bitbankã¸ã®æ¥ç¶šä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        return None



        if not api_key or not secret_key:
            print("ã‚¨ãƒ©ãƒ¼ï¼šAPIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ç’°å¢ƒå¤‰æ•°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚")
            return None

        # ccxtã‚’ä½¿ã£ã¦bitbankã«æ¥ç¶š
        exchange = ccxt.bitbank({
            'apiKey': api_key,
            'secret': secret_key,
        })
        print("bitbankã«ccxtã§æ¥ç¶šã—ã¾ã—ãŸã€‚")
        return exchange

    except Exception as e:
        print(f"bitbankã¸ã®æ¥ç¶šä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        return None

# === 2. ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã®å–å¾— ===
def get_ohlcv(exchange, pair='BTC/JPY', timeframe='1h', limit=250):
    """
    æŒ‡å®šã—ãŸé€šè²¨ãƒšã‚¢ã®OHLCVãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚(ccxtä½¿ç”¨)
    """
    try:
        ohlcv_data = exchange.fetch_ohlcv(pair, timeframe, limit=limit)

        if ohlcv_data:
            # ãƒ‡ãƒ¼ã‚¿ã‚’DataFrameã«å¤‰æ›
            df = pd.DataFrame(ohlcv_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df = df.set_index('timestamp')
            return df
        else:
            print(f"{pair} ã®OHLCVãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
            return None

    except Exception as e:
        print(f"OHLCVãƒ‡ãƒ¼ã‚¿ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        return None

# === 3. å£²è²·ã‚·ã‚°ãƒŠãƒ«ã®åˆ¤å®šï¼ˆMA 25/75/200 + è²·ã„å¢—ã—ãƒ­ã‚¸ãƒƒã‚¯ï¼‰ ===
def generate_signals(df):
    """
    ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ã„ã¦å£²è²·ã‚·ã‚°ãƒŠãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
    """
    # ãƒ‡ãƒ¼ã‚¿æ•°ãŒ200æœ¬å¿…è¦
    if df is None or len(df) < 200:
        print(f"DEBUG: ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚æœ€ä½200æœ¬å¿…è¦ã§ã™ãŒã€{len(df)}æœ¬ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã€‚")
        return None

    # çŸ­æœŸ25ã€ä¸­æœŸ75ã€é•·æœŸ200ã‚’è¿½åŠ 
    df['short_mavg'] = df['close'].rolling(window=25).mean()
    df['mid_mavg'] = df['close'].rolling(window=75).mean() # 75ã‚’midã«åç§°å¤‰æ›´
    df['long_mavg'] = df['close'].rolling(window=200).mean() # æ–°ã—ã„é•·æœŸMA

    latest_data = df.iloc[-1]
    previous_data = df.iloc[-2]
    signal = None

    # ğŸ”‘ ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
    is_uptrend = latest_data['mid_mavg'] > latest_data['long_mavg']
    mid_mavg_is_rising = latest_data['mid_mavg'] > previous_data['mid_mavg']

    # --- è²·ã„ã‚·ã‚°ãƒŠãƒ« 1ï¼šæ–°è¦ã‚¨ãƒ³ãƒˆãƒªãƒ¼ (ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ã‚¯ãƒ­ã‚¹) ---
    if (previous_data['short_mavg'] <= previous_data['mid_mavg'] and
        latest_data['short_mavg'] > latest_data['mid_mavg'] and
        is_uptrend and mid_mavg_is_rising):
        signal = 'buy_entry' # æ–°è¦ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚·ã‚°ãƒŠãƒ«
        print("âœ… æ–°è¦ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚·ã‚°ãƒŠãƒ« (GC 25/75ã€ãƒˆãƒ¬ãƒ³ãƒ‰ç¢ºèª) ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")

    # --- è²·ã„ã‚·ã‚°ãƒŠãƒ« 2ï¼šè²·ã„å¢—ã— (æŠ¼ã—ç›®) ---
    elif latest_data['close'] > latest_data['short_mavg'] and is_uptrend:
        signal = 'buy_add' # è²·ã„å¢—ã—ã‚·ã‚°ãƒŠãƒ«
        print("ğŸ“ˆ è²·ã„å¢—ã—ã‚·ã‚°ãƒŠãƒ« (æŠ¼ã—ç›®è²·ã„) ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")

    # --- å£²ã‚Šã‚·ã‚°ãƒŠãƒ«ï¼šå…¨æ±ºæ¸ˆ (ãƒˆãƒ¬ãƒ³ãƒ‰çµ‚äº†) ---
    # MA75ãŒMA200ã‚’ä¸‹å›ã£ãŸã€ã¾ãŸã¯MA75ãŒä¸‹å‘ãã«è»¢ã˜ãŸ
    elif not is_uptrend or latest_data['mid_mavg'] < previous_data['mid_mavg']:
        signal = 'sell_all'
        print("âŒ å…¨æ±ºæ¸ˆã‚·ã‚°ãƒŠãƒ« (é•·æœŸãƒˆãƒ¬ãƒ³ãƒ‰çµ‚äº†/åè»¢) ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")

    return signal

# === 4. æ³¨æ–‡ã®å®Ÿè¡Œ ===
def execute_order(exchange, pair, order_type, amount, price=None):
    """
    bitbankã«æ³¨æ–‡ã‚’å‡ºã—ã¾ã™ã€‚(ccxtä½¿ç”¨)
    """
    try:
        # ccxtã®create_orderãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨
        if order_type == 'buy':
            type = 'limit' if price else 'market'
            order = exchange.create_order(pair, type, 'buy', amount, price)
            print(f"{type} è²·ã„æ³¨æ–‡ã‚’ç™ºæ³¨ã—ã¾ã—ãŸ: {amount:.4f} {pair.split('/')[0]} {'@ ' + str(price) if price else ''}")
        elif order_type == 'sell':
            type = 'limit' if price else 'market'
            order = exchange.create_order(pair, type, 'sell', amount, price)
            print(f"{type} å£²ã‚Šæ³¨æ–‡ã‚’ç™ºæ³¨ã—ã¾ã—ãŸ: {amount:.4f} {pair.split('/')[0]} {'@ ' + str(price) if price else ''}")
        else:
            print(f"ç„¡åŠ¹ãªæ³¨æ–‡ã‚¿ã‚¤ãƒ—ã§ã™: {order_type}")
            return None

        if order:
            print("æ³¨æ–‡æˆåŠŸ:", order)
            return order
        else:
            print("æ³¨æ–‡ã«å¤±æ•—ã—ã¾ã—ãŸ:", order)
            return None

    except Exception as e:
        print(f"æ³¨æ–‡å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")
        return None

# === 5. ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—ï¼ˆBotã®å®Ÿè¡Œéƒ¨åˆ†ï¼‰ ===
# ğŸ”‘ ä¿®æ­£: APIã‚­ãƒ¼ã¨ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆã‚­ãƒ¼ã‚’å—ã‘å–ã‚‹å¼•æ•°ã‚’è¿½åŠ 
def run_bot(pair='BTC/JPY', interval_seconds=3600, api_key=None, secret_key=None):
    """
    è‡ªå‹•å£²è²·Botã®ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œãƒ«ãƒ¼ãƒ—ã§ã™ã€‚(ccxtä½¿ç”¨)
    """
    # ğŸ”‘ ä¿®æ­£: æ¥ç¶šé–¢æ•°ã«ã‚­ãƒ¼ã‚’æ¸¡ã™ã‚ˆã†ã«å¤‰æ›´
    exchange = connect_to_bitbank(api_key, secret_key)
    if not exchange:
        print("APIæ¥ç¶šã«å¤±æ•—ã—ãŸãŸã‚Botã‚’åœæ­¢ã—ã¾ã™ã€‚")
        return

    print(f"Botã‚’ {pair} ã§å®Ÿè¡Œã—ã¾ã™ã€‚ãƒ‡ãƒ¼ã‚¿å–å¾—é–“éš”: {interval_seconds}ç§’")

    # --- ğŸ”‘ã€åˆæœŸè¨­å®šã€‘æ³¨æ–‡æ•°é‡ã®è¨ˆç®—ã¨æœ€ä½æ³¨æ–‡å˜ä½ã®ãƒã‚§ãƒƒã‚¯ ---

    # 1. äºˆç®—ã¨æœ€ä½å–å¼•å˜ä½ã®è¨­å®š
    JAPANESE_YEN_BUDGET = 10000 # 1å›ã®æ³¨æ–‡ã«ä½¿ã†æ—¥æœ¬å††ã®äºˆç®—: 10,000å††
    MIN_ORDER_BTC = 0.001 # bitbank BTC/JPYã®æœ€ä½æ³¨æ–‡é‡ï¼ˆã“ã“ãŒå°†æ¥çš„ã«å¤‰ã‚ã‚‹å¯èƒ½æ€§ã‚ã‚Šï¼‰
    print(f"ğŸ’° 1å›ã‚ãŸã‚Šã®æ³¨æ–‡äºˆç®—: {JAPANESE_YEN_BUDGET} å††")
    print(f"ğŸ“‰ æœ€ä½æ³¨æ–‡æ•°é‡: {MIN_ORDER_BTC} BTC")

    # 2. æœ€æ–°ã®å¸‚å ´ä¾¡æ ¼ã‚’å–å¾—
    try:
        ticker = exchange.fetch_ticker(pair)
        latest_price = ticker['last']
        print(f"ğŸ’µ æœ€æ–°ã®å¸‚å ´ä¾¡æ ¼: {latest_price} å††")
    except Exception as e:
        print(f"ã‚¨ãƒ©ãƒ¼: æœ€æ–°ä¾¡æ ¼ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚Botã‚’åœæ­¢ã—ã¾ã™: {e}")
        return

    # 3. æ³¨æ–‡æ•°é‡ã‚’è¨ˆç®— (äºˆç®— Ã· ä¾¡æ ¼)
    buy_amount_per_order_raw = JAPANESE_YEN_BUDGET / latest_price
    # æœ€å°å–å¼•å˜ä½ï¼ˆ0.0001 BTCï¼‰ã«åˆã‚ã›ã¦åˆ‡ã‚Šæ¨ã¦ã‚‹
    buy_amount_per_order = math.floor(buy_amount_per_order_raw * 10000) / 10000

    # 4. ã€å®‰å…¨ãƒã‚§ãƒƒã‚¯ã€‘äºˆç®—ãŒæœ€ä½æ³¨æ–‡é‡ã‚’ä¸‹å›ã£ãŸã‹ç¢ºèª
    if buy_amount_per_order < MIN_ORDER_BTC:
         print("---------------------------------------------------------")
         print("ğŸš¨ è‡´å‘½çš„ãªè­¦å‘Š: äºˆç®—è¦‹ç›´ã—ãŒå¿…è¦ã§ã™ï¼")
         print(f"ç¾åœ¨ã®äºˆç®—({JAPANESE_YEN_BUDGET}å††)ã§ã¯ã€æœ€ä½æ³¨æ–‡é‡({MIN_ORDER_BTC} BTC)ã‚’")
         print(f"æº€ãŸã›ã¾ã›ã‚“ã€‚ç¾åœ¨ã®è¨ˆç®—é‡: {buy_amount_per_order:.4f} BTC")
         print("å°†æ¥ã®ä¾¡æ ¼é«˜é¨°ã«å‚™ãˆã€`JAPANESE_YEN_BUDGET`ã‚’å¢—é¡ã—ã¦ãã ã•ã„ã€‚Botã‚’åœæ­¢ã—ã¾ã™ã€‚")
         print("---------------------------------------------------------")
         return

    print(f"ğŸ›’ 1å›ã‚ãŸã‚Šã®æ³¨æ–‡æ•°é‡: {buy_amount_per_order:.4f} BTC")

    # -----------------------------------------------------

    timeframe = '1h'
    data_limit = 250

    while True:
        try:
            print("Bot loop iteration started.")

            # --- ğŸ”‘ã€è¿½åŠ ã€‘ãƒã‚¸ã‚·ãƒ§ãƒ³ã®æ­£ç¢ºãªå–å¾— ---
            # ãƒ«ãƒ¼ãƒ—ã®æœ€åˆã«APIã‹ã‚‰æ®‹é«˜ã‚’å–å¾—ã—ã€Botã®è¨˜æ†¶ã‚’ç¾å®Ÿã«åˆã‚ã›ã‚‹
            try:
                balance = exchange.fetch_balance()
                # BTCã®ä¿æœ‰é‡ã‚’æ­£ç¢ºã«å–å¾— (ã‚­ãƒ¼ã¯å–å¼•æ‰€ã¨ccxtã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã«ã‚ˆã‚Šç•°ãªã‚‹å¯èƒ½æ€§ã‚ã‚Š)
                current_position_amount = balance['total']['BTC']
                print(f"âœ… APIã‹ã‚‰å–å¾—ã—ãŸæ­£ç¢ºãªä¿æœ‰æ•°é‡: {current_position_amount} BTC")
            except Exception as e:
                print(f"âš ï¸ ã‚¨ãƒ©ãƒ¼: æ®‹é«˜ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å–å¼•ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™: {e}")
                time.sleep(interval_seconds)
                continue
            # ------------------------------------

            # ç¾åœ¨ã®æ—¥ä»˜ã¨æ™‚åˆ»ã‚’å–å¾— (JST)
            now_utc = datetime.datetime.now(datetime.timezone.utc)
            now_jst = now_utc.astimezone(JST)
            weekday = now_jst.weekday() # æœˆæ›œæ—¥ãŒ0ã€æ—¥æ›œæ—¥ãŒ6

            # åœŸæ›œæ—¥ (5) ã¾ãŸã¯æ—¥æ›œæ—¥ (6) ã§ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
            if weekday < 5:
                print(f"ç¾åœ¨æ™‚åˆ» (JST): {now_jst.strftime('%Y-%m-%d %H:%M:%S')} - å¹³æ—¥ãªã®ã§å–å¼•ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã€‚")
                time.sleep(interval_seconds)
                continue

            print(f"ç¾åœ¨æ™‚åˆ» (JST): {now_jst.strftime('%Y-%m-%d %H:%M:%S')} - é€±æœ«ãªã®ã§å–å¼•ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚")

            # 2. ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã®å–å¾—: 1æ™‚é–“è¶³ãƒ‡ãƒ¼ã‚¿ã‚’250æœ¬å–å¾—
            ohlcv_df = get_ohlcv(exchange, pair, timeframe=timeframe, limit=data_limit)

            if ohlcv_df is not None and not ohlcv_df.empty:
                # 3. å£²è²·ã‚·ã‚°ãƒŠãƒ«ã®åˆ¤å®šï¼ˆ25/75/200 MAï¼‰
                signal = generate_signals(ohlcv_df)

                # --- ğŸ”‘ æåˆ‡ã‚Šãƒ­ã‚¸ãƒƒã‚¯ã®åˆ¤å®šã¨å®Ÿè¡Œ ---
                if current_position_amount > 0.0:
                    latest_close = ohlcv_df.iloc[-1]['close']
                    # ä¸­æœŸMA(75)ã‚’æåˆ‡ã‚Šãƒ©ã‚¤ãƒ³ã¨ã—ã¦ä½¿ç”¨
                    mid_mavg = ohlcv_df.iloc[-1]['mid_mavg']

                    if latest_close < mid_mavg:
                        print(f"ğŸš¨ æåˆ‡ã‚Šã‚·ã‚°ãƒŠãƒ«ï¼çµ‚å€¤({latest_close})ãŒä¸­æœŸMA({mid_mavg})ã‚’ä¸‹å›ã‚Šã¾ã—ãŸã€‚")

                        # æåˆ‡ã‚Šã‚’å®Ÿè¡Œï¼ˆä¿æœ‰æ•°é‡ã‚’å…¨é‡å£²ã‚Šï¼‰
                        sell_amount = current_position_amount
                        order_result = execute_order(exchange, pair, 'sell', sell_amount, price=None)

                        if order_result:
                            print("ğŸ”¥ è²·ã„ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’æåˆ‡ã‚Šã«ã‚ˆã‚Šå…¨é‡è§£æ¶ˆã—ã¾ã—ãŸã€‚æ¬¡ã®ãƒ«ãƒ¼ãƒ—ã§æ®‹é«˜ã‚’ç¢ºèªã—ã¾ã™ã€‚")
                        else:
                            print("âš ï¸ æåˆ‡ã‚Šæ³¨æ–‡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚")


                # --- 4. æ³¨æ–‡ã®å®Ÿè¡Œ (ã‚¨ãƒ³ãƒˆãƒªãƒ¼/è²·ã„å¢—ã—/å…¨æ±ºæ¸ˆ) ---

                # è²·ã„ã‚·ã‚°ãƒŠãƒ« 1ï¼šæ–°è¦ã‚¨ãƒ³ãƒˆãƒªãƒ¼ (buy_entry)
                if signal == 'buy_entry' and current_position_amount == 0.0:
                    order_result = execute_order(exchange, pair, 'buy', buy_amount_per_order, price=None)

                # è²·ã„ã‚·ã‚°ãƒŠãƒ« 2ï¼šè²·ã„å¢—ã— (buy_add)
                elif signal == 'buy_add' and current_position_amount > 0.0:
                    order_result = execute_order(exchange, pair, 'buy', buy_amount_per_order, price=None)

                # å£²ã‚Šã‚·ã‚°ãƒŠãƒ«ï¼šå…¨æ±ºæ¸ˆ (sell_all)
                elif signal == 'sell_all' and current_position_amount > 0.0:
                    # å…¨é‡å£²ã‚Šï¼ˆåˆ©ç¢ºï¼‰
                    sell_amount = current_position_amount
                    order_result = execute_order(exchange, pair, 'sell', sell_amount, price=None)

                # ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè¡ŒçŠ¶æ³ã‚’è¡¨ç¤º
                print(f"ç¾åœ¨ã®ã‚·ã‚°ãƒŠãƒ«: {signal}, APIå–å¾—ã®æ­£ç¢ºãªä¿æœ‰æ•°é‡: {current_position_amount} BTC")

            else:
                print("ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ãŸãŸã‚ã€æ¬¡ã®ãƒ«ãƒ¼ãƒ—ã«é€²ã¿ã¾ã™ã€‚")

        except Exception as e:
            print(f"Botå®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {e}")

        # æŒ‡å®šã•ã‚ŒãŸé–“éš”ã§å¾…æ©Ÿ
        print(f"æ¬¡å›ã®å®Ÿè¡Œã¾ã§ {interval_seconds}ç§’å¾…æ©Ÿã—ã¾ã™...")
        time.sleep(interval_seconds)

# Botã‚’å®Ÿè¡Œ
if __name__ == "__main__":
  ã€€# ğŸ”‘ ä¿®æ­£: run_botã«æœ€ä¸Šéƒ¨ã§å®šç¾©ã—ãŸã‚­ãƒ¼ã‚’æ¸¡ã™
    run_bot('BTC/JPY', 3600, API_KEY, SECRET_KEY)

"""# Task
CONOHA VPSä¸Šã§ã€ç¾åœ¨Colabã§å‹•ä½œã—ã¦ã„ã‚‹Botã‚’å‹•ä½œã•ã›ã‚‹ã€‚

## Conoha vpsã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

### Subtask:
CONOHA VPSã‚’å¥‘ç´„ã—ã€OSï¼ˆä¾‹: Ubuntuï¼‰ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã€SSHã§æ¥ç¶šã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

## å¿…è¦ãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

### Subtask:
VPSã«Pythonã€pipã€ãã—ã¦BotãŒå¿…è¦ã¨ã™ã‚‹ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆccxt, pandas, pytzï¼‰ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚

## Botã‚³ãƒ¼ãƒ‰ã®è»¢é€

### Subtask:
ç¾åœ¨ã®Colab notebookã‹ã‚‰Botã®Pythonã‚³ãƒ¼ãƒ‰ã‚’VPSã«è»¢é€ã—ã¾ã™ã€‚

## Apiã‚­ãƒ¼ã®è¨­å®š

### Subtask:
Colabã®ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã§ã¯ãªãã€VPSä¸Šã§å®‰å…¨ãªæ–¹æ³•ï¼ˆç’°å¢ƒå¤‰æ•°ãªã©ï¼‰ã§APIã‚­ãƒ¼ã‚’è¨­å®šã—ã¾ã™ã€‚

## Botã®å®Ÿè¡Œ

### Subtask:
VPSä¸Šã§Botã®Pythonã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’å®Ÿè¡Œã—ã¾ã™ã€‚æ°¸ç¶šçš„ã«å®Ÿè¡Œã™ã‚‹ãŸã‚ã«ã€`screen`ã‚„`tmux`ã€ã¾ãŸã¯systemdãªã©ã®ãƒ„ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã‚’æ¤œè¨ã—ã¾ã™ã€‚

## ç›£è¦–ã¨ãƒ­ã‚°

### Subtask:
BotãŒæ­£å¸¸ã«å‹•ä½œã—ã¦ã„ã‚‹ã‹ç›£è¦–ã—ã€å•é¡Œç™ºç”Ÿæ™‚ã«ãƒ‡ãƒãƒƒã‚°ã§ãã‚‹ã‚ˆã†ãƒ­ã‚°ã‚’è¨­å®šã—ã¾ã™ã€‚

## Summary:

### Data Analysis Key Findings

* The entire process of migrating the bot from Colab to CONOHA VPS involves several steps that require manual interaction with the VPS environment, including setting up the VPS, installing software, transferring code, configuring API keys, executing the bot, and monitoring/logging.
* The current execution environment (Jupyter Notebook/Colab) does not support the necessary operations, such as SSH connections, remote file system interaction, and executing commands directly on the VPS.
* Consequently, none of the sub-tasks could be completed programmatically within the notebook environment.

### Insights or Next Steps

* The migration process requires direct access to and interaction with the CONOHA VPS via SSH.
* The user needs to perform the steps manually or use tools outside the Colab environment to complete the bot migration.
"""